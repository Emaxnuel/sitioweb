<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3js</title>

  <style>
			body { margin: 0; }
			canvas { display: block; width: 100%; height: 100vh; }
  </style>
</head>

<body>

  <canvas id="c"></canvas>
</body>

<script src="https://threejs.org/build/three.js"></script>
<script src="orbit.js"></script>
<script src="GLTFLoader.js"></script>
<script>
  function main() {
    const canvas = document.querySelector('#c');
    const renderer = new THREE.WebGLRenderer({
      canvas
    });

    renderer.autoClearColor = false;

    const fov = 75;
    const aspect = 2; // the canvas default
    const near = 0.1;
    const far = 100;
    const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
    camera.position.z = 3;

    const controls = new THREE.OrbitControls(camera, canvas);
    controls.target.set(0, 0, 0);
    controls.update();

    const scene = new THREE.Scene();
    const fogNear = 1;
    const fogFar = 3;
    const color = 'white';
    scene.fog = new THREE.Fog(color, fogNear, fogFar);
    scene.background = new THREE.Color(color);

    {
      const color = 0xFFFFFF;
      const intensity = 1;
      const light = new THREE.DirectionalLight(color, intensity);
      light.position.set(-1, 2, 4);
      scene.add(light);
    }

    var loader = new THREE.GLTFLoader();
    loader.load('zen.gltf', (gltf) => {
      scene.add(gltf.scene);
    });

    const bgScene = new THREE.Scene();
    let bgMesh; {
      const loader = new THREE.TextureLoader();
      const texture = loader.load(
        'space.jpg',
      );
      texture.magFilter = THREE.LinearFilter;
      texture.minFilter = THREE.LinearFilter;

      const shader = THREE.ShaderLib.equirect;
      const material = new THREE.ShaderMaterial({
        fragmentShader: shader.fragmentShader,
        vertexShader: shader.vertexShader,
        uniforms: shader.uniforms,
        depthWrite: false,
        side: THREE.BackSide,
      });
      material.uniforms.tEquirect.value = texture;
      const plane = new THREE.BoxBufferGeometry(2, 2, 2);
      bgMesh = new THREE.Mesh(plane, material);
      bgScene.add(bgMesh);
    }

    function resizeRendererToDisplaySize(renderer) {
      const canvas = renderer.domElement;
      const width = canvas.clientWidth;
      const height = canvas.clientHeight;
      const needResize = canvas.width !== width || canvas.height !== height;
      if (needResize) {
        renderer.setSize(width, height, false);
      }
      return needResize;
    }

    function render(time) {
      time *= 0.001;

      if (resizeRendererToDisplaySize(renderer)) {
        const canvas = renderer.domElement;
        camera.aspect = canvas.clientWidth / canvas.clientHeight;
        camera.updateProjectionMatrix();
      }

      bgMesh.position.copy(camera.position);
      renderer.render(bgScene, camera);
      renderer.render(scene, camera);

      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);
  }

  main();
</script>

</html>